# yelp-seach
A simple iOS app to play with Yelp's GraphQL API, Swift's Combine framework and iOS 13's new `UICollectionView` features.

## Architecture:
This app uses MVVM architecture. Reactive programming is also heavily used with Swift's `Combine` framework. I am still new to `Combine` and I tried my best to learn and apply the best practice, but I am sure I made plenty of mistakes. Thus, any kinds of feedbacks are very welcomed!

## Usage of graphQL:
Recently, I have done several small projects for different interviews. Most of them connects to RESTFul APIs, and I did it in different ways, such as using 3rd part frameworks (e.g. Alamofire) or creating my own simple network layer with `URLSession` from scratch. This time, when I see Yelp provides a graphQL version of their API, I felt it's a perfect chance for me to try graphQL out: I've known graphQL for years, but never have a chance to try it in an iOS project.

To connect to Yelp's graphQL api, I used a 3rd party framework named [`Apollo`](https://github.com/apollographql/apollo-ios). I am completely new to grapQL, so I basically followed `Apollo`'s [tuturial](https://www.apollographql.com/docs/ios/tutorial/tutorial-introduction/). Basically, for files inside the `GraphQL` folder, except for those `.graphql` files, they are all automatically generated by `Apollo` through the `Apollo CLI` script phrase in the project's build phrases. I need to mentioned here, because there's a `schema.json` and a `API.swift` file. Both of them are quite large and complicated, but one is generated according to Yelp's graphQL API spec, the other one is generated based on the `.graphql` files. Thus, they don't really affect the scalability of the project.

To confine the usage of `Apollo`, I create a protocol named `Service` with a method that has default implementation to use `Appolo` to make request to the graphQL API. I am sure there are lots of room of improvement for my usage of graphQL here. So any kinds of feedbacks are very welcomed for this part too!

## Testability:
With MVVM and protocol-oriented programming, although I didn't implementing any unit tests due to time limitation, I still consider this project to be highly testable. Dependency injection can be done through initializer or public properties. For example, `BusinessSearchViewModel` has only one initializer, which takes 3 parameters; one of them is a `BusinessSearch` protocol type, where `BusinessSearch` defined the interface for making a search request. Thus, a "mock" type could be provided for doing unit tests for this view model.

## A Playground for iOS 13 New Features:
In the requirement of this project, no iOS version limited is provided. I didn't ask, but made the decision to use the latest iOS release, which is iOS 13. This is because I learnt a lot of iOS 13 new features since last year's WWDC, but never have much chance to apply them in any project for various of reasons. So for this project, I really want to use some of them to: 1) demostrate my ability to learn and adopt new technologies; 2) to make this project more fun to work with (As I mentioned above, I've done several similar projects recently, and for each of them, I always try to do something different.).

The iOS 13 new feature I used in this project includes:
* `Combine` framework: for reactive programming, which is widely used in the entire app. Basically, there's no "completion" closure being used in this app. Every asynchronous method uses `Combine`.
* `UICollectionViewCompositionalLayout`: for layout cells for search result. Because the usage of this, plus the cell has self-sufficient auto-layout constraints , the search result collection view support **any devices size in any orientation**: the size of the cell will be dynamically determined at runtime.
* `UICollectionViewDiffableDataSource`: for providing the data source for the collection view used by the search result. Comparing to the old `UICollectionViewDataSource` approach, this new way reduces quite some boilerplate code, and makes updating the collection view less error-prone.
* `Dark Mode`: the app also support dark mode, because I only used `semantic` colors instead of fixed color.

## Other Assumptions/Decisions:
* Sorting for search result: the requirement asks for sorting the search result by name. However, Yelp's graphQL only support 4 kind of sorting, namely: `best_match`, `rating`, `review_count` and `distance`. So for this project, I used distance to sort the results. When the app is launched for the 1st time, it will ask permission to use the GPS location. If location permission is not granted, then for simplicity, a default coordinate near Montreal will be used.
* More about sorting the result: although `distance` is specified as the sorting method when making the search request, Yelp's API doesn't guarantee the order. According to its API documentation: "note that specifying the sort_by is a suggestion (not strictly enforced) to Yelp's search, which considers multiple input parameters to return the most relevant results."
* Showing reviews: the requirement also asks for "showing the latest review". Yelp's graphQL only provides a "snippet" of the reviews, which as far as I see contains up to 3 relatively recent reviews. For this project, I just displayed them all.
